



Network Working Group                                         F. Günther
Internet-Draft                                     IBM Research - Zurich
Intended status: Informational                                D. Stebila
Expires: 4 May 2025                               University of Waterloo
                                                               S. Veitch
                                                              ETH Zurich
                                                         31 October 2024


                           Kemeleon Encodings
                         draft-kemeleon-latest

Abstract

   This document specifies Kemeleon encoding, algorithms for encoding
   ML-KEM public keys and ciphertexts as random bytestrings.  Kemeleon
   encodings provide obfuscation of public keys and ciphertexts, relying
   on module LWE assumptions.  This document specifies a number of
   variants of these encodings, with differing rejection rates, output
   sizes, and performance profiles.

About This Document

   This note is to be removed before publishing as an RFC.

   The latest revision of this draft can be found at
   https://ssveitch.github.io/draft-kemeleon/draft-kemeleon.html.
   Status information for this document may be found at
   https://datatracker.ietf.org/doc/draft-kemeleon/.

   Source for this draft and an issue tracker can be found at
   https://github.com/ssveitch/draft-kemeleon.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 4 May 2025.

Copyright Notice

   Copyright (c) 2024 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components
   extracted from this document must include Revised BSD License text as
   described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Revised BSD License.

Table of Contents

   1.  Introduction
   2.  Conventions and Definitions
   3.  Notation / ML-KEM Background
   4.  Kemeleon encoding
     4.1.  Common functions
     4.2.  Encoding public keys
     4.3.  Encoding ciphertexts
     4.4.  Deterministic variant
     4.5.  Faster arithmetic variant
     4.6.  Non-rejection sampling variant
     4.7.  Summary of encodings
   5.  Obfuscated KEMs
   6.  Security Considerations
     6.1.  Randomness sampling
     6.2.  Timing side-channels
   7.  IANA Considerations
   8.  References
     8.1.  Normative References
     8.2.  Informative References
   Appendix A.  Acknowledgments
   Authors' Addresses

1.  Introduction

   ML-KEM [FIPS203] is a post-quantum key-encapsulation mechanism (KEM)
   recently standardized by NIST, Many applications are transitioning
   from classical Diffie-Hellman (DH) based solutions to constructions
   based on ML-KEM.  The use of Elligator and related Hash-to-Curve
   [RFC9380] algorithms are ubiquitous in DH-based protocols where DH
   shares are required to be encoded as, and look indistinguishable
   from, random bytestrings.  For example, applications using Elligator
   include protocols used for censorship circumvention in Tor [OBFS4],
   password-authenticated key exchange (PAKE) protocols [CPACE]
   [OPAQUE], and private set intersection (PSI) [ECDH-PSI].

   For the post-quantum transition, an analogous encoding for (ML-)KEM
   public keys and ciphertexts to random bytestrings is required.  This
   document specifies such an encoding, Kemeleon, for ML-KEM public keys
   and ciphertexts.  Kemeleon was introduced in [GSV24] for building an
   (post-quantum) "obfuscated" KEM whose public keys and ciphertexts are
   indistinguishable from random.  Beyond the original construction,
   this document additionally specifies variants that avoid the encoding
   failing or the use of large integer computations, or allow for a
   deterministic encoding.  Aside from these variants, it is notable
   that the Kemeleon encodings of public keys results in smaller
   representations than in the original ML-KEM specification.

2.  Conventions and Definitions

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all
   capitals, as shown here.

3.  Notation / ML-KEM Background

   A KEM consists of three algorithms:

   *  'KeyGen() -> (ek, dk)': A probabilistic key generation algorithm
      that, with no input, generates a public (encapsulation) key 'ek'
      and a secret (decapsulation) key 'dk'.

   *  'Encaps(ek) -> (c, K)': A probabilistic encapsulation algorithm
      that takes as input a public key 'ek', and outputs a ciphertext
      'ct' and shared secret key 'K'.

   *  'Decaps(dk, c) -> K': A decapsulation algorithm that takes as
      input a secret key 'dk' and ciphertext 'c', and outputs a shared
      secret key 'K'.

   TODO: * ML-KEM specifics (q, compress, decompress, ...)

   ML-KEM.KeyGen() (Section 7.1 [FIPS203]) produces a public key, ek,
   (termed an encapsulation key in [FIPS203]) and a private key, dk,
   (decapsulation key).  Public keys consist of byte-encoded vectors of
   coefficients in Z_q, where each coefficient is encoded in 12 bits,
   together with a 32-byte seed for generating the matrix A.  ML-
   KEM.Encaps(ek) (Section 7.2 [FIPS203]) produces ciphertexts
   consisting of byte-encoded compressed vectors of cofficients, where
   each coefficient in Z_q is compressed by a certain number of bits
   (depending on the ML-KEM parameter set).

   The following terms and notation are used throughout this document:

   *  msb(x) refers to the most significant bit of the value x

   *  a[i] denotes the ith position of a vector a of coefficients

   *  concat(x0, ..., xN): returns the concatenation of bytestrings.

4.  Kemeleon encoding

   At a high level, the constructions in this document instantiate the
   following functions:

   *  EncodePk(ek) -> eek is the (possibly randomized) encoding
      algorithm that on input a public key, outputs an obfuscated public
      key or an error.

   *  DecodePk(eek) -> ek is the deterministic decoding algorithm that
      on input an obfuscated public key, outputs a public key.

   *  EncodeCtxt(c) -> ec is the (possibly randomized) encoding
      algorithm that on input a ciphertext, outputs an obfuscated
      ciphertext or an error.

   *  DecodeCtxt(ec) -> c is the deterministic decoding algorithm that
      on input an obfuscated ciphertext, outputs a ciphertext.

4.1.  Common functions

   VectorEncode(a):
      r = 0
      for i from 1 to k*n:
         r += q^(i-1)*a[i]
      if msb(r) == 1:
         return err
      else:
         return r

   VectorDecode(r):
      for i from 1 to k*n:
         t = 0
         for j from 1 to i-1:
            t += a[j]
         a[i] = (r - t)/(q^(i-1)) % q
      return a

   The following algorithm recovers randomness from a compressed
   ciphertext coefficient.  The mapping is based on the Compress_d,
   Decompress_d algorithms from (Section 4.2.1 [FIPS203]).

   RecoverFrom_d(u,c):
      if d == 10:
         if Compress_d(u - 2) == c:
            rand <--$ [-2,-1,0,1]
         else:
            rand <--$ [-1,0,1]
         return u + rand
      if d == 11:

      else:
         return err

4.2.  Encoding public keys

   Kemeleon1.EncodePk(ek = (t, rho)):
      r = VectorEncode(t)
      if r == err:
         return err
      else:
         return concat(r,rho)

   Kemeleon1.DecodePk(eek):
      r,rho = eek // rho is fixed lenght
      t = VectorDecode(r)
      return (t, rho)

4.3.  Encoding ciphertexts

   TODO: complete

   Kemeleon1.EncodeCtxt(c = (c_1,c_2)):
      u = Decompress_d(c_1,d_u)
      for i from 1 to k*n:
         x = RecoverFrom_d(u[i],c[i])

4.4.  Deterministic variant

4.5.  Faster arithmetic variant

4.6.  Non-rejection sampling variant

4.7.  Summary of encodings

   +===============+=========+=========+=============+================+
   | Algorithm     | pk size | ct size |     Success |     Additional |
   |               | (bytes) | (bytes) | probability | considerations |
   +===============+=========+=========+=============+================+
   | Kemeleon1-512 |         |         |             |                |
   +---------------+---------+---------+-------------+----------------+

                                 Table 1

5.  Obfuscated KEMs

   This section describes how to use the above specified encoding
   algorithms in conjunction with a KEM to produce an obfuscated KEM
   [GSV24].

6.  Security Considerations

   This section contains additional security considerations about the
   Kemeleon encodings described in this document.

6.1.  Randomness sampling

   Both public key and ciphertext encodings in the original Kemeleon
   encoding are randomized.  The randomness (or seed used to generate
   randomness) MUST NOT be derived from a public source.  For public key
   encodings, randomness can be stored with the respective secret key.
   In particular, using a public source of randomness would reveal ...

6.2.  Timing side-channels

   (also from resampling)

7.  IANA Considerations

   This document has no IANA actions.

8.  References

8.1.  Normative References

   [CPACE]    Abdalla, M., Haase, B., and J. Hesse, "CPace, a balanced
              composable PAKE", Work in Progress, Internet-Draft, draft-
              irtf-cfrg-cpace-13, 14 October 2024,
              <https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-
              cpace-13>.

   [FIPS203]  "Module-Lattice-Based Key-Encapsulation Mechanism
              Standard", National Institute of Standards and Technology,
              DOI 10.6028/nist.fips.203, August 2024,
              <https://doi.org/10.6028/nist.fips.203>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/rfc/rfc2119>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/rfc/rfc8174>.

   [RFC9380]  Faz-Hernandez, A., Scott, S., Sullivan, N., Wahby, R. S.,
              and C. A. Wood, "Hashing to Elliptic Curves", RFC 9380,
              DOI 10.17487/RFC9380, August 2023,
              <https://www.rfc-editor.org/rfc/rfc9380>.

8.2.  Informative References

   [ECDH-PSI] wangyuchen, Chang, Lu, Y., Hong, C., and J. Peng, "PSI
              based on ECDH", Work in Progress, Internet-Draft, draft-
              ecdh-psi-00, 21 October 2024,
              <https://datatracker.ietf.org/doc/html/draft-ecdh-psi-00>.

   [GSV24]    Günther, F., Stebila, D., and S. Veitch, "Obfuscated Key
              Exchange", 2024, <https://eprint.iacr.org/2024/1086>.

   [OBFS4]    "obfs4 (The obfourscator)", n.d.,
              <https://gitlab.torproject.org/tpo/anti-censorship/
              pluggable-transports/lyrebird/-/blob/HEAD/doc/
              obfs4-spec.txt>.

   [OPAQUE]   Bourdrez, D., Krawczyk, H., Lewi, K., and C. A. Wood, "The
              OPAQUE Augmented PAKE Protocol", Work in Progress,
              Internet-Draft, draft-irtf-cfrg-opaque-17, 27 September
              2024, <https://datatracker.ietf.org/doc/html/draft-irtf-
              cfrg-opaque-17>.

Appendix A.  Acknowledgments

   TODO acknowledge.

Authors' Addresses

   Felix Günther
   IBM Research - Zurich
   Email: mail@felixguenther.info


   Douglas Stebila
   University of Waterloo
   Email: dstebila@uwaterloo.ca


   Shannon Veitch
   ETH Zurich
   Email: shannon.veitch@inf.ethz.ch
